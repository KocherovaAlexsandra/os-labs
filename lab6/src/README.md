# Лабораторная работа №6

## Структуры и алгоритмы обработки данных

**Вариант:** 0 — *Сортировка пузырьком*
**Бригада:** *Кочерова А.А. Аэ-21-22*

---

## Описание задания

В этой лабораторной работе требуется:

1. Реализовать алгоритм согласно варианту (вариант 0 — **пузырьковая сортировка**).
2. Выполнить реализацию алгоритма с использованием **трёх структур данных**:

   * `ArrayList`
   * `LinkedList`
   * `ArrayDeque`
3. Сгенерировать входные данные различных размеров.
4. Измерить время работы сортировки.
5. Вывести результаты в консоль.
6. Добавить аналитическую оценку сложности алгоритма.

---

## Используемые структуры данных

| Структура      | Причина выбора                 | Особенности                                      |
| -------------- | ------------------------------ | ------------------------------------------------ |
| **ArrayList**  | Базовая динамическая структура | Быстрый доступ по индексу → пузырёк эффективнее  |
| **LinkedList** | Связный список                 | Нет случайного доступа → сортировка через массив |
| **ArrayDeque** | Очередь/стек                   | Также нет индексов → сортировка через массив     |

---

## Алгоритм сортировки пузырьком (Bubble Sort)

Сравнивает пары соседних элементов и меняет их местами, если они стоят "неправильно".
Таким образом большие элементы «всплывают» к концу массива.

**Характеристики:**

| Случай  | Сложность |
| ------- | --------- |
| Лучший  | `O(N)`    |
| Средний | `O(N²)`   |
| Худший  | `O(N²)`   |

---

## Результаты работы программы

Пример вывода:

```
=== Размер: 100 ===
ArrayList:  1 ms
LinkedList: 0 ms
ArrayDeque: 0 ms

=== Размер: 1000 ===
ArrayList:  5 ms
LinkedList: 6 ms
ArrayDeque: 5 ms

=== Размер: 5000 ===
ArrayList:  92 ms
LinkedList: 105 ms
ArrayDeque: 98 ms
```
---

## Описание работы программы

Программа выполняет экспериментальное сравнение скорости работы алгоритма пузырьковой сортировки при использовании трёх различных структур данных: **ArrayList**, **LinkedList** и **ArrayDeque**. Работа программы включает следующие этапы:

---

### 1. Формирование наборов входных данных

Для заранее определённых размеров (`100`, `1000`, `5000`, `10000`) программа:

1. создаёт массив случайных чисел методом `generateArray()`,
2. заполняет этими данными три структуры данных:

   * `ArrayList<Integer>`
   * `LinkedList<Integer>`
   * `ArrayDeque<Integer>`

Каждая структура получает **одинаковые исходные данные**, чтобы результаты сортировок были корректно сопоставимы.

---

### 2. Сортировка данных

Для каждой структуры вызывается отдельная реализация пузырьковой сортировки:

#### **ArrayList**

Сортировка выполняется напрямую над структурой — элементы сравниваются и меняются местами с помощью методов `get()` и `set()`.

#### **LinkedList**

Так как прямой доступ по индексу в `LinkedList` медленный, программа:

1. извлекает элементы в обычный массив,
2. сортирует массив пузырьком,
3. очищает список и заполняет его отсортированными значениями.

#### **ArrayDeque**

Поскольку у `ArrayDeque` нет индексированного доступа, применяется тот же подход:

1. преобразование в массив,
2. сортировка массива,
3. возврат данных обратно в `ArrayDeque`.

Каждая сортировка использует классический алгоритм пузырька `O(N²)`.

---

### 3. Измерение времени выполнения

Время работы каждой сортировки измеряется с помощью:

```
System.currentTimeMillis()
```

Замер включает:

* для ArrayList: только сам процесс сортировки;
* для LinkedList и ArrayDeque: извлечение данных → сортировка массива → обратное заполнение.

Разница между временем "до" и "после" вычисляется и возвращается в миллисекундах.

---

### 4. Вывод результатов

После сортировки всех структур данных программа выводит в консоль:

* размер входного набора
* время сортировки каждой структуры данных

Пример вывода:

```
=== Размер: 1000 ===
ArrayList:  28 ms
LinkedList: 45 ms
ArrayDeque: 39 ms
```

Это позволяет визуально оценить, какая структура данных обеспечивает более быстрое выполнение пузырьковой сортировки.

---


## Как запустить

```bash
javac Main.java
java Main
```

---

## Итог

* Реальное время растёт квадратично → соответствует **O(N²)**.
* `ArrayList` быстрее других, что объясняется случайным доступом.
* `LinkedList` и `ArrayDeque` требуют преобразования в массив, что добавляет накладные расходы.
* Все структуры демонстрируют поведение, соответствующее теории.

